---
title: c++知识点--关键字
date: 2022-03-04 11:42:47
tags:
- 语言
categories: 
- c++
toc: true
typora-root-url: ..\img
---
#### 静态关键字（static）

- 静态成员（类）函数和变量都是类共有；在初始化的时候分配全局区的静态区空间；sizeof 类对象的时候排除静态成员变量大小；静态成员函数只能调用静态的成员函数或者变量；静态成员变量在程序结束的时候释放空间

- 静态全局变量从定义开始只在本文件中可见，其他文件中不能使用，即使定义为extern的也不行
- 静态局部变量在全局数据区分配内存；静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
<!-- more -->
#### 引用和指针

- 引用是个别名，指针是类型；指针有空间大小，引用没有；指针不需要强制初始化，引用必须初始化；指针有多级，引用只有一级并且不用

#### std :: function和std :: bind的

- 用途是安全函数指针。std::bind是用于把已知函数和某个形式的参数列表进行绑定，形成新的函数（函数调用对象）来适应原函数（调用对象）的参数列表；可以理解为一个通用函数适配器；

- 形式：

  ```c++
  auto new_callback = std::bind(func,  args_list);
  //调用new_callback的时候会调用func，把args_list中的参数传递给func，其中args_list中可能包含形如_n的名字，其中n是整数，表示新生成的可调用对象中参数的位置，_1表示一个参数，_2第二个；
  ```

- 样例

  ```c++
  using namespace std;
  using namespace std::placeholders;
  void func(std::vector<int>& vect, int start, int num) {
      for (int i = start; i < vect.size(); i++) {
          if (vect[i] >= num) {
              std::cout << vect[i] << " ";
          }
      }
  }
  
  int main() {
      std::vector<int> vect{1,23,4,5,3,2,7,0};
      auto new_callback = std::bind(func, _1, 0, 5);
      new_callback(vect);
      return 0;
  }
  ```

  可以改变参数个数和顺序；也可以绑定引用，通过ref标准库函数；

  std::function实现函数的回调；

#### inline

##### 使用

- 使用起来很简单直接在函数定义处加上inline关键字，注意是定义处

- 在类的头文件直接声明定义的不需要加参数会自动inline
  但是如果是头文件声明(不加inline的类函数声明)，.cpp定义那就还是需要函数定义加上inline

##### 优点

- 表示对小函数在编译的时候展开，不进行压栈（改变esp指针）；减少函数调用次数，节省开支；容易代码膨胀；
##### 编译器级别


- 关于函数属性 always_inline，一般inline只有特定优化等级才会内联。而对于声明always_inline的函数，会一直保持内联，而且不论有没有指定优化等级。

- 阻止inline，可以使用函数属性 __noinline__ 。即使使用了建议inline关键字修饰，__noinline__ 也会阻止真正内联。

###### 堆栈

- 缓存方式
  - 栈：一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放。
  - 堆：二级缓存，[生命周期](https://so.csdn.net/so/search?q=生命周期&spm=1001.2101.3001.7020)由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。堆可以被看成一颗树，如堆排序

#### 其他

- 哪些函数不能是虚函数：构造函数、静态函数、模板函数（编译时生成代码）、友元函数（编译时替换）
- raii【resource acquire is init ]通过在资源获取时通过对象来初始化资源，然后使用资源（对象），在对象声明周期结束的时候释放资源；【构造函数---析构函数】
- RTTI【running time type identify】
- - 通过typeid能返回类型或者变量的具体类型
  - 通过dynamic_cast 进行类对象的类型转换，一般是向下转，存在转失败，返回nullptr的情况。
- auto:模板类型推到
- mutable声明变量是可变的，是能是非静态和非常量的变量里用，但是可以再常量成员函数中可以改变值；
