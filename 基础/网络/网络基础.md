---
title: 网络基础
date: 2022-02-17 18:42:47
tags:
- 基础
categories: 
- 网络
toc: true
typora-root-url: ..\img
---
- time_wait 是主动发起关闭连接的一方所处的状态，如果这一方有大量的time_wait,可能是短链接，也可能就是流量大了【攻击】；

   - 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭 
   - net.ipv4.tcp_tw_reuse = 1 
   - \#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭 
   - net.ipv4.tcp_tw_recycle = 1 
   - 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间 
   - net.ipv4.tcp_fin_timeout=30

- close_wait:一般是漏写close函数

  <!-- more -->

- tcp

  - 为了解决这个问题，TCP引入了窗口，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。ack包中的win是告诉对端，我方的接受窗口是多大，接受能力。
  - 发送端不能疯狂地向接收端发送数据，因为接收端接收不过来的话，接收方只能把处理不过来的数据存在缓存区里。如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源啦。TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的据量，这就是流量控制。TCP通过滑动窗口来控制流量。

- ##### 流量控制（copy）

  - TCP通过滑动窗口来控制流量，我们看下流量控制的**简要流程**吧：
  - 首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。
  - ![图片](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/640)TCP的流量控制
  - 假如当前发送方给接收方发送了200个字节，那么，发送方的`SND.NXT`会右移200个字节，也就是说当前的可用窗口减少了200 个字节。
  - 接受方收到后，放到缓冲队列里面，REV.WND =400-200=200字节，所以win=200字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口200字节
  - 发送方又发送200字节过来，200字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理100字节，剩余的100字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100字节，即win=100返回发送方。
  - 发送方继续干活，发送100字节过来，这时候，接受窗口win变为0。
  - 发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到win大于0，才继续开始发送。

- ##### 拥塞控制

  - 定义：拥塞控制是**作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况**。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟**流量控制**又有什么区别呢？流量控制是作用于接收者的，根据**接收端的实际接收能力控制发送速度**，防止分组丢失的。我们可以把网络链路比喻成一根水管，如果我们想最大化利用网络来传输数据，那就是尽快让水管达到最佳充满状态。

  ![net2](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net2.jpg)

  发送方维护一个**拥塞窗口cwnd（congestion window）** 的变量，用来估算在一段时间内这条链路（水管）可以承载和运输的数据（水）的数量。它大小代表着网络的拥塞程度，并且是动态变化的，但是为了达到最大的传输效率，我们该如何知道这条水管的运送效率是多少呢？

  一个比较简单的方法就是不断增加传输的水量，直到水管快要爆裂为止（对应到网络上就是发生丢包），用 TCP 的描述就是：

  > ★
  >
  > 只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。
  >

  实际上，拥塞控制主要有这几种常用算法：**慢启动、拥塞避免、拥塞发生、快速恢复**

  ###### 慢启动算法

  慢启动算法，表面意思就是，别急慢慢来。它表示TCP建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，**每收到一个ACK，就将拥塞窗口cwnd大小就加1（单位是MSS）**。**每轮次**发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。

  TCP连接完成，初始化cwnd = 1，表明可以传一个MSS单位大小的数据。

  每当收到一个ACK，cwnd就加一;

  每当过了一个RTT，cwnd就增加一倍; 呈指数让升

  ![net3](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net3.jpg)

  为了防止cwnd增长过大引起网络拥塞，还需设置一个**慢启动阀值ssthresh**（slow start threshold）状态变量。当`cwnd`到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当**cwnd >ssthresh**时，进入了**拥塞避免**算法。

  ###### 拥塞避免算法

  一般来说，慢启动阀值ssthresh是65535字节，`cwnd`到达**慢启动阀值**后

  每收到一个ACK时，cwnd = cwnd + 1/cwnd

  当每过一个RTT时，cwnd = cwnd + 1

  显然这是一个线性上升的算法，避免过快导致网络拥塞问题。

  ![net4](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net4.jpg)

  #### 拥塞发生

  当网络拥塞发生**丢包**时，会有两种情况：RTO超时重传和快速重传；如果是发生了**RTO超时重传**，就会使用拥塞发生算法；慢启动阀值sshthresh =  cwnd /2，cwnd 重置为 1，进入新的慢启动过程

  ![net5](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net5.jpg)

  这真的是**辛辛苦苦几十年，一朝回到解放前**。其实还有更好的处理方式，就是**快速重传**。发送方收到3个连续重复的ACK时，就会快速地重传，不必等待**RTO超时**再重传。

  ![net6](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net6.jpg)

  慢启动阀值ssthresh 和 cwnd 变化如下：拥塞窗口大小 cwnd = cwnd/2，慢启动阀值 ssthresh = cwnd，进入快速恢复算法

  ###### 快速恢复

  快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有3个重复ACK收到，说明网络也没那么糟糕，所以没有必要像RTO超时那么强烈。正如前面所说，进入快速恢复之前，cwnd 和 sshthresh已被更新：

  ```
  - cwnd = cwnd /2
  - sshthresh = cwnd
  ```

  然后，真正的快速算法如下：cwnd = sshthresh  + 3，重传重复的那几个ACK（即丢失的那几个数据包）如果再收到重复的 ACK，那么 cwnd = cwnd +1；如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。

  ![net7](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net7.jpg)

- 半连接队列和全连接队列

- 1. 半连接队列（SYN队列）：发送了开始建立连接的
  2. 全连接队列（ACCEPT队列）: 客户端也发送了ack之后就放入全连接队列

- socket阻塞是相对于发生在io读写的时候，一般读io是非阻塞的，而写io都是阻塞的；我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。
