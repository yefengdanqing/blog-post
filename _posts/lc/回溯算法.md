---
title: 递归和树总结
toc: true
date: 2025-04-02 22:26:59
tags:
- 
categories:
- 
typora-root-url: ..\img

---

#### 概念

![截屏2025-04-11 13.57.24](/../../../../Desktop/截屏2025-04-11 13.57.24.png)

回溯算法框架

```c++
void func_question(arr) {
  type result;
  bracktrace(arr, arg1, arg2, arg3);
}
void bracktrace(arr, arg1, arg2, arg3) {
  //是否根据条件加入
  if (条件满足) {
  		result.add(args);
    	return;
  }
  for 选择 in 选择列表 {
    增加到arg1（选择）
    bracktrace(arr, arg1, arg2, arg3)
    从arg1中移除（撤销）
  }
}
```

排列：不重复元素的排列，需要一个used数组来标记用过的，否则会重复；对于重复元素的序列（排序），不仅要used 标记数组，还需要判断前后两个元素是否相等。**但排列问题本身就是让你穷举元素的位置，`nums[i]` 之后也可以出现 `nums[i]` 左边的元素，所以之前的那一套玩不转了，需要额外使用 `used` 数组来标记哪些元素还可以被选择**。

子集：自己相当于回溯的时候，每个元素都需要加入结果集合中；每次遍历都是在当前元素获取之后，排除当前元素【**通过保证元素之间的相对顺序不变来防止出现重复的子集**】；对于重复元素的组合，用类似的判断前后元素是否相等来做剪枝。

组合：组合所模拟的多叉数，对于结果可以根据对应层的个数来确定（比如n里面的个数为k的组合）【**通过保证元素之间的相对顺序不变来防止出现重复的子集**】（比如传入start作为起始，然后根据顺序来递归

刚才讲的组合/子集问题使用 `start` 变量保证元素 `nums[start]` 之后只会出现 `nums[start+1..]` 中的元素，通过固定元素的相对位置保证不出现重复的子集。

**体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现 `nums[i] == nums[i-1]`，则跳过**

```c++
// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}
// 选择 nums[i]
```



##### 

#### 举例

##### 总结

##### 题目

![416.分割等和子集1](https://file.kamacoder.com/pics/20210117171307407.png)

<!-- more -->

#### 遗留的问题
