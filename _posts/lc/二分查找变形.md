---
title: 二分查找总结
toc: true
date: 2022-02-22 15:26:49
tags:
- leetcode
categories:
- 算法
---

##### 问题

```c++
左右边界初始值为什么有这么多种组合? 
(l = 0, r = n - 1; l = 0, r = n; l = -1, r = n; 其中 n = nums.length)
「左闭右闭」、「左闭右开」、「左开右开」是个啥？
「模版一」、「模版二」、「模版三」是个啥？
y总模版是个啥？红蓝二分法是个啥？
C++中的lower_bound, upper_bound是个啥？
Python中的bisect_left, bisect_right是个啥？
while 中的条件什么时候用 <，什么时候用 <= ?
中间值下标为什么写成 l + (r - l) / 2 ？貌似还有其他写法？
左右界更新条件的不等号该写哪一个 <, <=, >, >= ?
左右界更新语句该写哪一个 l = c + 1 / l = c / r = c - 1 / r = c ？
为什么我写的二分会陷入无限循环？
循环终止时l、r下标的关系是怎么确定的？为什么是确定的？
返回值到底是 l 还是 r 还是 l - 1, l + 1, r - 1, r + 1...？
听说二分查找不需要数组有序，只需要具备「二段性」即可，元素大小甚至可以是随机的？really？
所以什么是「二段性」？
据说有些什么「求最大值最小化」问题，属于比较难的二分问题？这又是什么意思？
为什么这么简单的算法思想却这么难写对？这是玄学吗？

https://leetcode.cn/discuss/post/ooxfo8/

```

##### 循环不变原理

```c++
// 模版一「相等返回」写法
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){ // 循环条件
            int c = l + (r - l) / 2; // 中间值坐标
            if(nums[c] == target) return c; // 相等返回
            else if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧元素「必」大于target 
        }
        return -1; 
    }
}

```

```c++
else if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
else r = c - 1; // #2 更新后r右侧元素「必」大于target 
```

循环不变的逻辑：

在程序运行过程中，中间值要么等于 target 直接返回答案，要么执行 #1 或 #2 。基于上述两个不变的关系，若执行 #1，则更新后的 l 左侧元素为 target 的可能性被完全排除，若执行 #2，则更新后的 r 右侧元素为 target 的可能性被完全排除。再次强调，这两个「关系」对于更新后任意时刻的 l 和 r 来说都是「不变」的。同时强调的是「更新后」这一前提，因为若 target 比 nums 中所有元素都大，则 r 不会经历更新，若 target 比 nums 中所有元素都小，则 l 不会经历更新。不经历更新，就不具有前述两条「循环不变」的关系。

四种一般情形
四种一般情形与模版一时所述相同，均依据「循环不变」原则写出，在书写「情形3」代码时我们发现程序陷入 「无限循环」 ，然后分析该问题发生的原因，并给出正确写法。

![ebfe18990f9e19320dd2b98a982cda5c](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/ebfe18990f9e19320dd2b98a982cda5c.png)

##### 情形1--大于等于

```c++
{
  int len = arr.size();
  int left = 0, right = len - 1;
  while (left <= right) {
  		mid = left + (right -left)/2;
    if (arr[mid] < target) {
      	left = mid + 1;
    } else {
      	right = mid -1;
    }
  }
}
```



##### 情形2--大于

##### 情形3--小于等于

##### 情形4--小于

| 情形            | 本文规定的返回值                                             | 「插入位置」返回值                                           | 备注 |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| 相等返回情形    | 有相等元素时返回等于下标否则返回 -1                          | 有相等元素时返回插入后有序的「插入位置下标」<br />有多个相等元素时，无法保证插入位置是哪一个元素的下标 |      |
| 情形1: 大于等于 | 有相等元素时返回等于下标<br/>否则返回刚好大于下标<br/>否则返回 -1 | 即返回 **第一个** 满足插入后有序的「插入位置下标」           |      |
| 情形2: 大于     | 不考虑相等，返回刚好大于下标<br/>否则返回 -1                 | 即返回 **最后一个** 满足插入后有序的「插入位置下标」         |      |
| 情形3: 小于等于 | 有相等元素时返回等于下标<br/>否则返回刚好小于下标<br/>否则返回 -1 | 不适合用「插入位置」理解                                     |      |
| 情形3: 小于等于 | 不考虑相等，返回刚好小于下标<br/>否则返回 -1                 | 不适合用「插入位置」理解                                     |      |
|                 |                                                              |                                                              |      |

![image.png](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/1652191568-jyZSyy-image.png)

二分查找

https://www.zhihu.com/question/36132386/answer/530313852?utm_source=qq&utm_medium=social&utm_oi=37067136434176

```c++
#include "skt.h"
   //lower_bound，大于等于某个数
   int l = 0, r = nums.size(), mid = 0;
   while (l < r) {
       mid = l + (r-l)/2;
       if (nums[mid] < target) {
           l = mid + 1;
       } else {
            r = mid;
       }
    }
	return l;
    //upper_bound, 大于给定元素值所在的位置,之前的位置刚好相等
    int x = 0, y = nums.size();
    mid = 0;
    while (x < y) {
        mid = x + (y-x)/2;
        if (nums[mid] <= target) {
             x = mid + 1;
         } else {
             y = mid;
         }
    }
	return x;
	//x-1 是小于等于目标数的位置
    //唯一区别就是一个是小于，一个是小于等于;区间都是左闭右开；右边界不用减1
```

<!-- more -->

变形

```
int binary_eg(std::vector<int>& vect, int target) {
    int l = 0, r = vect.size() - 1;
    int mid = 0;
    while(l <= r) {
        mid = (l+r) / 2;
        if (target <= vect[mid]) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return l;
}
//大于
int binary_gt(std::vector<int>& vect, int target) {
    int l = 0, r = vect.size() - 1;
    int mid = 0;
    while(l <= r) {
        mid = (l+r) / 2;
        if (target < vect[mid]) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return l;
}
//小于等于---大于减1或者返回right
int binary_lt(std::vector<int>& vect, int target) {
    return binary_gt(vect, target) - 1;
}
int binary_lt1(std::vector<int>& vect, int target) {
    int l = 0, r = vect.size() - 1;
    int mid = 0;
    while(l <= r) {
        mid = (l+r) / 2;
        if (target < vect[mid]) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return r;
}
//小于
int binary_ls(std::vector<int>& vect, int target) {
    return binary_eg(vect, target) - 1;
}
int binary_ls1(std::vector<int>& vect, int target) {
    int l = 0, r = vect.size() - 1;
    int mid = 0;
    while(l <= r) {
        mid = (l+r) / 2;
        if (target <= vect[mid]) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return r;
}
int main() {
    std::vector<int> nums = {2,3,4,5,5,5,5,6,7,9,9,9,10,11};
    std::cout << "vector size:" << nums.size() << std::endl;
    std::cout << "eg:" << binary_eg(nums,9) << std::endl;
    std::cout << "gt:" << binary_gt(nums,9) << std::endl;
    std::cout << "lt:" << binary_lt(nums,9) << std::endl;
    std::cout << "lt1:" << binary_lt1(nums,9) << std::endl;
    std::cout << "ls:" << binary_ls(nums,9) << std::endl;
    std::cout << "ls1:" << binary_ls1(nums,9) << std::endl;
}
```

