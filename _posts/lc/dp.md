---
title: 模板
toc: true
date: xxxx-xx-xx 22:26:59
tags:
- 
categories:
- 
typora-root-url: ..\img

---

#### 背景

* dp一般是求值问题
* **求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后再找最值
* xx

#### 思想

首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出**正确的「状态转移方程」**，才能正确地穷举。而且，你需要判断算法问题是否**具备「最优子结构」**，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题**存在「重叠子问题」**，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

#### 框架

##### 自顶向下

```c++
//自顶向下的动态规划,这种一般都是用递归实现
//这里选择和状态x的关系是什么;选择是每个状态里面所有的情况
func dp(状态1, 状态2, 状态3, ....) {
  for 选择 in 所有可能的选择 {
    result = max/min(result, dp(状态1, 状态2, 状态3, ....))
  }
  return result;
}

```

##### 自底向上

```c++
//自底向上一般都是for循环的迭代
func dp(状态1, 状态2, 状态3, ....) {
  dp_table[0][1][2] = base case
  for 状态1 range 状态1的所有取值 {
  		for 状态2 range 状态2的所有取值 {
  			for ...{
          //多个选择可以用for 循环来确定
          dp[状态x] = max/min(选择1，选择2，选择3)
        }
      }
}
```



#### 概念

动态规划用于求解具有重叠子问题和最优子结构的问题。例如最长子序列、背包问题、最短路径；重叠子问题是指在求解过程中，会多次用到子问题的解来辅助当前的问题的求解；

* 动态规划一般都是让你求最值。

* 求解最值最普通的方法就是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。
* **其实「自底向上」和「自顶向下」本质是一样的，只是视角不同而已**。
* **明确「状态」-> 明确「选择」 -> 定义 `dp` 数组/函数的含义**

<!-- more -->

### [自顶向下 vs 自底向上](https://labuladong.online/algo/essential-technique/dynamic-programming-framework-2/#自顶向下-vs-自底向上)

其实如果你只掌握上面的内容，就已经掌握动态规划的解题方法了：无非就是先写出暴力解法，然后用「备忘录」剪枝消除重叠子问题嘛，动态规划就是这么简单。

不过肯定有读者会提问，为什么我见过的很多动态规划解法就是几个 for 循环，好像并不包含递归，也没见到什么备忘录之类的东西，这是怎么回事呢？

实际上，动态规划解法确实有两种表现形式：

第一种是带备忘录的递归解法，或称为「自顶向下」的解法，也就是我们上面展示的，一个递归函数带一个 `memo` 备忘录。

第二种是 DP table 的迭代解法，或称为「自底向上」的解法，也就是你说的，用 for 循环去迭代 `dp` 数组进行求解。

**这两者的本质是一样的，可以互相转化。迭代解法中的那个 `dp` 数组，就是递归解法中的 `memo` 数组**。

为啥叫「自顶向下」？比如刚才的递归解法，多次点击 `if (n == 0 || n == 1)` 可以看到递归树从上向下生长，从一个规模较大的原问题 `f(5)`，向下逐渐分解规模，直到 `f(0)` 和 `f(1)` 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？就是反过来嘛。我们直接从最底下、最简单、问题规模最小、已知结果的 `f(0)` 和 `f(1)`（base case）开始往上推出 `f(2), f(3)...` 最后推出我们想要的 `f(5)`，这就是「自底向上」。

**其实「自底向上」和「自顶向下」本质是一样的，只是视角不同而已**。

比如我把上面写的带备忘录的递归解法稍微改一改，把对 base case `n == 0 || n == 1` 的处理从递归函数 `dp` 中移到 `memo` 数组中，这应该没问题吧？我们再来看 `fib(5)` 的计算过程。

你可以多次点击 `memo[n] = dp(memo, n - 1) + dp(memo, n - 2)` 这一行代码，**请注意递归树和 `memo` 数组的变化**：可以看到，递归树从下向上传递结果的过程，就是 `memo` 数组从 base case 向右推算的过程，这就叫自底向上，是不是很直观？

到这里你应该也观察出来了，其实整个计算过程就是在从左到右计算 `memo` 的值，那又何苦用递归了，搞这么复杂。一个 for 循环是不是就够用了？



那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？

**1、确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

**2、确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

**3、明确 `dp` 函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

动态规划的核心设计思想是数学归纳法。

相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么**我们先假设这个结论在 `k < n` 时成立，然后根据这个假设，想办法推导证明出 `k = n` 的时候此结论也成立**。如果能够证明出来，那么就说明这个结论对于 `k` 等于任何数都成立。

类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 `dp[0...i-1]` 都已经被算出来了，然后问自己：怎么通过这些结果算出 `dp[i]`？

直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 `dp[i]` 的值到底代表着什么？



##### 问题

找零钱的自顶向下的递归遍历,注意初始条件



##### 





https://github.com/shichangzhi/fucking-algorithm-book/blob/main/%E7%AC%AC1%E7%AB%A0-%E6%A0%B8%E5%BF%83%E5%A5%97%E8%B7%AF%E7%AF%87/1.2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6.md