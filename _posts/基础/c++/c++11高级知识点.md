---
title: c++11高级知识点学习1
date: 2022-02-21 11:42:47
tags:
- 语言
categories: 
- c++
toc: true
typora-root-url: ..\img
---

### 右值

右值：没有地址并且即将消失

将亡值：有地址，并且即将

<!-- more -->

除了用右值引用接收纯右值会产生将亡值外，还可以通过move把左值强制转换成将亡值，这个强制转换仅仅是告诉编译器这个左值被转换成了将亡值，不会对它的地址和内容做任何改变。（move也可以接收一个纯右值，这时编译器会给这个纯右值分配地址，所以有人说move会延长临时对象的生存期。）

### thread_local

| static       | static变量只初始化一次，除此之外它还有可见性的属性： \1. static修饰函数内的“局部”变量时，表明它不需要在进入或离开函数时创建或销毁。且仅在函数内可见。 \2. static修饰全局变量时，表明该变量仅在当前(声明它的)文件内可见。 \3. static修饰类的成员变量时，则该变量被该类的所有实例共享。 |
| ------------ | ------------------------------------------------------------ |
| external     | 引用一个全局变量。当在一个文件中定义了一个全局变量时，就可以在其它文件中使用extern来声明并引用该变量。 |
| register     | 寄存器变量。该变量存储在CPU寄存器中，而不是RAM(栈或堆)中。该变量的最大尺寸等于寄存器的大小。由于是存储于寄存器中，因此不能对该变量进行取地址操作 |
| mutable      | 仅适用于类成员变量。以mutable修饰的成员变量可以在const成员函数中修改。 |
| Thread_local | 变量在线程创建时生成;线程结束时被销毁;每个线程都拥有其自己的变量副本;thread_local可以和static或extern联合使用，这将会影响变量的链接属性;需要注意的一点是，如果类的成员函数内定义了 thread_local 变量，则对于同一个线程内的该类的多个对象都会共享一个变量实例，并且只会在第一次执行这个成员函数时初始化这个变量实例，这一点是跟类的静态成员变量类似的；**thread_local 作为类成员变量时必须是 static 的**。 |

Thread_local变量在main线程和t线程中分别保留了一份副本(有自己的作用域），以下时序图表明了两份副本的生命周期。

### std::reference_wrapper

用于按引用传递对象给 std::bind或 std::thread的构造函数

#### std::ref()

#### std::cref()

### thread

`std::thread` 的构造函数签名为：

```
c++复制代码template<class _Callable, class ... _Args>
explicit thread(_Callable&& __f, _Args&&... __args);
```

其中，`_Callable` 是可调用对象的类型，`_Args` 是参数包，用于指定调用可调用对象时需要传递的参数。此构造函数会创建一个新线程并启动它，新线程会执行 `__f(std::forward<_Args>(__args)...)`。

下面对这些参数进行详细解释：

- `_Callable&& __f`：表示要在新线程中执行的可调用对象，可以是函数指针、函数对象、成员函数指针等。
- `_Args&&... __args`：表示传递给可调用对象的参数包，可以是任意类型的值或引用，数量可以是 0 或多个。

需要注意以下几点：

- `_Callable` 类型必须支持移动语义（即具有移动构造函数）。
- `_Args` 中的参数必须是可转发的（forwardable），即支持完美转发（perfect forwarding）。
- 如果要传递引用类型的参数，需要使用 `std::ref()` 将其转换为引用封装类型，以便正确地传递引用而不是复制值。
- 在创建新线程之前，必须确保所有传递给 `std::thread` 的参数都已经存在，否则可能会导致未定义行为或错误。

总之，可以看出 `std::thread` 的构造函数非常灵活，可以用于启动不同类型和任意数量的线程，并且支持完美转发。在使用时需要注意参数类型的匹配和正确性，以便避免可能的错误或未定义行为。



### mutex

std::unique_lock 和std::lock_guard都是通过raii实现自动加锁和释放锁，lock_guard速度相对unique快点，而unique相对灵活和慢点。std::unique_lock无参数的构造函数是没有加锁的，不拥有互斥量的锁权利。

### 仿函数

仿函数，其实就是重载了括号运算符 () 的对象, 不过它具有函数的一些性质, 可以在需要函数的地方（主要是**各种**[**容器**](https://cloud.tencent.com/product/tke?from=20065&from_column=20065)**和算法**）使用。

```c++
// 仿函数(functor)
class Functor
{
public:
    int operator()(int a)
    {
        return a;
    }
};
```

优点：

* 仿函数可以不带痕迹地传递上下文参数。而回调技术通常使用一个额外的void*参数传递。这也是多数人认为回调技术丑陋的原因。
* 更好的性能。

### function

类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。

功能：

* 可以实现c的函数指针的功能，作为回调函数
* 可以作为函数参数进行传递
* 可以将仿函数赋值给function，然后调用function。

关于可调用实体转换为std::function对象需要遵守以下两条原则：

* 转换后的std::function对象的参数能转换为可调用实体的参数；
  可调用
* 实体的返回值能转换为std::function对象的返回值。
  std::function对象最大的用处就是在实现函数回调（实际工作中就是用到了这一点），使用者需要注意，它不能被用来检查相等或者不相等，但是可以与NULL或者nullptr进行比较。

可以实现移动和拷贝

```c++
TEST(FUNCTION_TEST, POSITIVE) {
    Callback = Factorial;
    ASSERT_EQ(1, Callback(-1));
    Callback = func_lambda;
    ASSERT_EQ(10, Callback(0));
    CompareObject obj;
    Callback = obj;
    std::cout << obj(10) << std::endl;
    ASSERT_EQ(10, Callback(10));

    Base a1;
    Callback = std::bind(&Base::add, a1, std::placeholders::_1);
    ASSERT_EQ(4, Callback(2));
}
```

### std::promise

<future> 头文件中包含了以下几个类和函数

- Providers 类：std::promise, std::package_task
- Futures 类：std::future, shared_future.
- Providers 函数：std::async()
- 其他类型：std::future_error, std::future_errc, std::future_status, std::launch.

promise 含义是承诺，承诺给别人反馈一个结果。std::promise保存的值可被与之关联的std::future读取，读取操作可以发生在其它线程。std::promise**允许move**语义(右值构造，右值赋值)，但**不允许拷贝**(拷贝构造、赋值)，std::future亦然。与future一起使用，std::promise 通过get_future赋值给一个future，然后就可以get这个future。std::promise和std::future合作共同实现了多线程间通信。

* 设置std::promise的值 set_value();对应的future将可以使用
* 通过std::promise让std::future抛出异常
* std::promise<void>
  * 我们看到std::promise<void>是合法的。此时std::promise.set_value不接受任何参数，仅用于通知关联的std::future.get()解除阻塞

* std::async(异步运行)时，开发人员有时会对std::promise所在线程退出时间比较关注。std::promise支持定制线程退出时的行为：
  std::promise::set_value_at_thread_exit 线程退出时，std::future收到通过该函数设置的值。
  std::promise::set_exception_at_thread_exit 线程退出时，std::future则抛出该函数指定的异常。

### std::future

#### 使用方式

**std::future通常与std::async()函数和std::promise、std::packaged_tast对象一起使用** 

也可以是某个函数自己返回一个std::future

#### 概念

std::future提供了一种访问异步操作结果的机制。从字面意思来理解，它表示未来，我觉得这个名字非常贴切，因为一个异步操作我们是不可能马上就获取操作结果的，只能在未来某个时候获取，但是我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态：

- deferred：异步操作还没开始

- ready：异步操作已经完成

- timeout：异步操作超时
  获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果（调用线程阻塞式的），wait只是等待异步操作完成，没有返回值，wait_for是超时等待返回结果。

```c++
//查询future的状态
std::future_status status;
    do {
        status = future.wait_for(std::chrono::seconds(1));
        if (status == std::future_status::deferred) {
            std::cout << "deferred\n";
        } else if (status == std::future_status::timeout) {
            std::cout << "timeout\n";
        } else if (status == std::future_status::ready) {
            std::cout << "ready!\n";
        }
    } while (status != std::future_status::ready);
```

#### 实现原理

自旋锁

### std::packaged_task

std::packaged_task允许传入一个函数，并将函数计算的结果传递给std::future，包括函数运行时产生的异常

```c++
template<class R, class... ArgsType>
class packaged_task<R(ArgsType...)>;
//其中R是一个函数或可调用对象，ArgTypes是R的形参
```

std::packaged_task封装的函数的计算结果会通过与之联系的std::future::get获取(当然，可以在其它线程中异步获取)。关联的std::future可以通过std::packaged_task::get_future获取到，get_future仅能调用一次，多次调用会触发std::future_error异常。
 std::package_task除了可以通过可调用对象构造外，还支持缺省构造(无参构造)。但此时构造的对象不能直接使用，需通过右值赋值操作设置了可调用对象或函数后才可使用。判断一个std::packaged_task是否可使用，可通过其成员函数valid来判断。

* std::packaged_task::valid

* std::packaged_task::operator()(ArgTypes...)

* 让std::packaged_task在线程退出时再将结果反馈给std::future

  * std::packaged_task::make_ready_at_thread_exit函数接收的参数与operator()(_ArgTypes...)一样，行为也一样。只有一点差别，那就是不会将计算结果立刻反馈给std::future，而是在其执行时所在的线程结束后，std::future::get才会取得结果。

* std::packaged_task::reset

  * 与std::promise不一样， std::promise仅可以执行一次set_value或set_exception函数，但std::packagged_task可以执行多次，其奥秘就是reset函数

  * 通过重新构造一个promise来达到多次调用的目的。显然调用reset后，需要重新get_future，以便获取下次operator()执行的结果。由于是重新构造了promise，因此reset操作并不会影响之前调用的make_ready_at_thread_exit结果，也即之前的定制的行为在线程退出时仍会发生。

  * ```c++
    template<class _Rp, class ..._ArgTypes>
    void packaged_task<_Rp(_ArgTypes...)>::reset()
    {
        if (!valid())
            __throw_future_error(future_errc::no_state);
        __p_ = promise<result_type>();
    }
    ```

### std::async

async异步的完成一个操作，简单的创建线程，然后通过std::future来获取结果

```c++
//(C++11 起) (C++17 前)
template< class Function, class... Args>
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>
    async( Function&& f, Args&&... args );

//(C++11 起) (C++17 前)
template< class Function, class... Args >
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>
    async( std::launch policy, Function&& f, Args&&... args );  
```

需要记住的3点：

- std::async的默认发射策略既允许任务异步执行，又允许任务同步执行。
- 这个灵活性（上一点）导致了使用thread_local变量时的不确定性，它隐含着任务可能不会执行，它还影响了基于超时的wait调用的程序逻辑。
- 如果异步执行是必需的，指定std::launch::async发射策略

### std::bind

std::bind用于创建函数对象(std::function),他能将某些参数绑定到函数或者函数对象上，并且返回一个*新的可调用对象*；bind 可以绑定成员函数、普通函数以及可调用对象；并且函数也可以可以绑定部分或者全部参数。

如果bind普通函数，假设当有两个参数，一个用placeholder::_1，另一个直接绑定某个参数或者常量值，返回的函数对象其实只有一个参数

bind成员函数的时候，除了class_name::func这个参数的时候，下一个参数一定是对象的引用或者指针，比如&obj, this。

### std::optional
#### 概念

`std::optional`是C++17中的一个类模板，用于表示可选对象。它是一个容器，可以包含或不包含值，类似于"可空类型"

以下是`std::optional`的一些关键特性：

- 它可以与任何类型一起使用，包括用户定义的类型。

- 它具有一个值构造函数，用于使用值初始化可选对象。

- 它具有默认构造函数，用于创建一个空的可选对象。

- 它有方法来检查它是否包含值（`has_value()`），访问包含的值（`value()`），或者在它为空时访问默认值（`value_or()`）。

- 它支持移动语义，因此可以有效地传递和从函数返回

#### 性能
那么在使用optional做参数、返回值传递时，optional包裹着的对象是否会进行拷贝、移动等增大程序开销的操作呢？如果会，该如何避免？

* 若以引用类型实例化`optional`则程序非良构。std::optional<const string&>写法不合理
* 如果const std::optional<string>& x，具体的string对象还是会进行copy
* std::reference_wrapper可以实现类似引用的封装，【就等价于const T*，T*占用的内存还要比std::optional<std::reference_wrapper<T>>小】
* 真要说有什么使用上的优势，那么应该就是相比T*表义更为清晰、以及在传参时不需要加取地址符&了吧，或许这对部分人来说很重要，但为了方便一般还是推荐使用T*，只在传递足够小的对象比如int时，使用std::optional



### std::any

### std::variant

### std::holds_alternative

### clear和swap测试

### decltype

### tuple使用

### __builtin_expect

### std::apply

std ::apply主要是把std::tuple转化为函数的参数，然后去调用函数



### std::enable_if

std::enable_if 标识满足条件时类型才可用，编译不会报错。

```c++
template<bool, typename T = void>
struct enable_if {};
template<typename T>
struct enable_if<true, T> {
		using type = T;
};
```

第一个是enable_if的泛化定义；第二个是偏特化版本，保证只有当条件为第二个参数T可以被使用

### std::is_base_of

这个特性是c++11,用于检查一个类型是否为另一个类型的基类，结合std::enable_if时常用于模板编程,使用案例

std::is_base_of<Base, Derived>::value == true/false

### shared_from_this

###  conditional_t

* 当我们新加一个类C的时候，有时候需要继承A,有时候需要继承B,我们怎么做呢？

  ```c++
  class A{};
  class B{};
  //使用模板就能解决上面的问题
  template<class T>
  class C :public T {};
  C<A> ca;
  c<B> cb;
  ```

### 回调为啥不能捕获this

### traits

#### std::is_same<T1, T2>和std::decay

std::is_same对int和const int\int &\const int&等都是区别对待的，但在写模板函数时，经常会强制指定常引用进行传参，以免进行数据拷贝，这时候is_same就做出了不相等的判断，但是有时候其实我们还是希望TYPE和const TYPE& 是能认为是一样的，这时就需要std::decay进行退化处理

```c++
TEST(Function, FunctionFuncPtr) {
    using func_ptr = int (*)(std::string&, int, int);
    std::function<int(std::string&, int, int)> func;
    ASSERT_EQ(1,1);
    bool is_int = std::is_same<int, int>::value;
    EXPECT_TRUE(is_int);
    bool type_result = std::is_same<func_ptr, std::function<int(std::string&, int, int)>>::value;
    // EXPECT_TRUE(type_result);
    EXPECT_FALSE(type_result);
}
```

#### is_void

```c++
template<typename T>
struct is_void {
  
};
```

### 模板的特化与偏特化

1. C++ 模板本身就是一种泛化编程的技术
2. 为了使模板能够被使用，我们需要进行模板的特化
3. 模板是泛化的表现，可以指定不同类型做相同的表现。而特化是指对于某些特殊的类型（类型模板参数），进行特殊的处理。需要注意的是，必须先有了泛化版本(模板），才会有对应的特化版本。
4. 所谓特化，就是将泛型的东东搞得具体化一些，从字面上来解释，就是为已有的模板参数进行一些使其特殊化的指定，使得以前不受任何约束的模板参数，或受到特定的修饰（例如const或者摇身一变成为了指针之类的东东，甚至是经过别的模板类包装之后的模板类型）或完全被指定了下来。
5. 特化可以简单理解将抽象转化成具体
6. 全特化就是模板参数全部被具体指定为某个类型；【全特化也就是定义了一个全新的类型，全特化的类中的函数可以与模板类不一样。】
7. 偏特化就是模板参数没有完全定下来，在编译的时候有代码去推导出来？？
8. 可以通过宏定义来实现不同的全特化

#### 函数模板特化

---

函数模板没有偏特化

##### 函数模板的全特化：模板参数列表为空，需要给出模板实参

函数模板全特化相当于函数模板泛化的一次实例化，并不是函数的重载

即 存在函数的重载，又存在函数的全特化，编译器的编译顺序为：

函数的重载  > 函数全特化版本 > 函数的泛化

```c++
//函数模板的条件重载
template <typename T>
typename std::enable_if<std::is_same<T, std::string>::value, T>::type add (T a, T b) {
    T result = a + " " + b;
    return result;
}

template<typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type add(T a, T b) {
    std::cout << "type:" << typeid(a).name() << " " << typeid(b).name()<< std::endl;
    print_type_name<T>();
    T result = a + b;
    return result;
}

template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, T>::type add(T a, T b) {
    std::cout << "type:" << typeid(a).name() << " " << typeid(b).name()<< std::endl;
    print_type_name<double>();
    double result = a * 100 + b * 100;
    return result;
}

//泛化和特化,特化是相对于模板类型的某个特定类型的详细定义
template<typename T>
T decrease(T a, T b) {
    std::cout << "type:" << typeid(a).name() << " " << typeid(b).name()<< std::endl;
    return a - b;
}
//函数的全特化版本
template<>
std::string decrease(std::string a, std::string b) {
    std::cout << "type:" << typeid(a).name() << " " << typeid(b).name()<< std::endl;
    return b + " " + a;
}
```

##### 模板函数与普通函数的使用细节

普通函数可以发生类型的隐式转换；而类模板参数则根据类型推导出，如果通过自动类型推导，编译器是无法知道的；只有通过显示类型的调用，才会进行一般的类型转化

对于有模板函数和普通函数，当我们想调用模板函数时，可以通过传入空的参数模板来调用，如func_name<>

函数模板也可以重载

对于模板函数和普通函数，哪个匹配，优先调用哪个

```c++
template<typename T>
int foo() {
  T a;
  return 10;
}
// template<>
// int foo() {
//   int a = 10;
// }
//上面显示定义错误，需要现实指定模板参数
template<>
int foo<int>() {//需要现实指出
  int a = 10;
  return a;
}
```

---

#### 类模板的特化

类模板可以特化为几种类型：

​	特化为一些确定的绝对类型

​	特化为引用、指针类型，比如const T&, const T*, T&等，这些就包括了int*

​	特化为另外一个类模板,特化版本编译器会优先选择

​	c++要求模板特化必须在实例化之前定义，否则报冲突的错误。

```c++
template <typename K, typename V, template<typename, typename> typename C>
class CommonFileDict {
public:
    CommonFileDict(const std::string& file_name) {
        std::cout << "泛化构造函数:" << typeid(*this).name() << std::endl;
        _dict_file = file_name;
    }
  	void function_print(const K& key, const V& value) {
      std::cout << "泛化的function_print:" << typeid(*this).name() << " " << typeid(key).name() << " " << typeid(value).name() << " " << typeid(kv_container).name() << std::endl;  
    }
private:
  C<K, V> kv_container;
};
```

在进行模板特化时，`template<>`是必须的，它告诉编译器你正在定义一个特化版本，而不是一个普通的模板实例化。这有助于编译器区分通用模板和特化版本，并正确处理特定类型的实现

##### 类模板的成员函数特化

在类内声明特化：需要使用`template<>`明确表示这是一个特化。

在类外定义特化：也需要使用`template<>`，以确保编译器理解这是一种特化而不是普通模板实例化。

##### 类模板的全特化：

```c++
template<>
class CommonFileDict<std::string, int, std::map> {
public:
    void insert(const std::string& key, const int& value);
    void add(const std::string& key, const int& value) {
        auto iter = kv_container.find(key);
        if (iter == kv_container.end()) {
            kv_container[key] = value;
        } else {
            iter->second = iter->second + value;
        }
    }
private:
    int count;
    std::string name;
    std::string _dict_file;
    std::map<std::string, int> kv_container;

};

void CommonFileDict<std::string, int, std::map>::insert(const std::string& key, const int& value) {
    kv_container[key] = value;
}
```

全特化类模板的成员函数，必须放在类内定义；不能单独提到类外定义

泛化的类模板成员函数，可以在类内定义，类外定义

**自动类型推导**：在大多数情况下，编译器可以根据传递的参数自动推导模板参数的类型。

**显式指定类型**：在某些特殊情况下，编译器无法推导出模板参数的类型，或者为了明确指定模板参数的类型，可以在调用模板函数时显式指定模板参数,比如多个参数的情况

##### 类模板的偏特化





### std::pmr::polymorphic_allocator

 https://github.com/MeouSker77/Cpp17/blob/master/markdown/src/ch29.md

### arena内存分配

https://blog.csdn.net/okiwilldoit/article/details/110138697















