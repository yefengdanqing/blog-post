---
title: 基础语法
toc: true
date: 2025-11-12 22:26:59
tags:
- 语言
categories:
- rust
typora-root-url: ..\img
---

### 基础语法

#### 变量

变量默认是不可改变的（immutable）；当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值；通过let来定义变量（常量和变量）；`mut` 表明了其他代码将会改变这个变量值的意图；

#### 常量

类似于不可变变量，*常量 (constants)* 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。

首先，不允许对常量使用 `mut`。常量不光默认不可变，它总是不可变。声明常量使用 `const` 关键字而不是 `let`，并且 *必须* 注明值的类型。

常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值

#### 遮蔽

我们可以定义一个与之前变量同名的新变量。称之为第一个变量被第二个 **遮蔽（Shadowing）** 了，这意味着当您使用变量的名称时，编译器将看到第二个变量。实际上，第二个变量遮蔽了第一个变量，此时任何使用该变量名的行为中都会视为是在使用第二个变量，直到第二个变量自己也被遮蔽或第二个变量的作用域结束。可以用相同变量名称来遮蔽一个变量，以及重复使用 `let` 关键字来多次遮蔽。

#### 数据类型

在 Rust 中，每一个值都有一个特定 **数据类型**（*data type*），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。

<!-- more -->

#### 标量

**标量**（*scalar*）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。

##### 整型

| 长度     | 有符号  | 无符号  |
| -------- | ------- | ------- |
| 8-bit    | `i8`    | `u8`    |
| 16-bit   | `i16`   | `u16`   |
| 32-bit   | `i32`   | `u32`   |
| 64-bit   | `i64`   | `u64`   |
| 128-bit  | `i128`  | `u128`  |
| 架构相关 | `isize` | `usize` |

##### 浮点数

Rust 的浮点数类型是 `f32` 和 `f64`，分别占 32 位和 64 位。默认类型是 `f64`，因为在现代 CPU 中，它与 `f32` 速度几乎一样，不过精度更高。

##### bool

##### char

#### 复合类型

**复合类型**（*Compound types*）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）

##### 元组类型

元组是一个将多个不同类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。

```rust
let tuples: (i32, bool, char, f64) = (1, true, 'c', 3.44);
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup;
//首先创建了一个元组并绑定到 tup 变量上。接着使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y 和 z。这叫做 解构（destructuring），因为它将一个元组拆成了三个部分;我们也可以使用点号（.）后跟值的索引来直接访问所需的元组元素
```

不带任何值的元组有个特殊的名称，叫做 **单元（unit）** 元组。这种值以及对应的类型都写作 `()`，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。

##### 数组

Rust 中的数组与一些其他语言中的数组不同，Rust 中的数组长度是固定的

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

#### 函数

你也见过 `fn` 关键字，它用来声明新函数。Rust 代码中的函数和变量名使用 *snake case* 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。

```rust
fn function(name1: i32, name2: bool)->i32 {}
```

返回值：使用 `return` 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。

#### 控制流

##### if

代码中的条件**必须**是 `bool` 值。如果条件不是 `bool` 值，我们将得到一个错误。

使用 `else if` 处理多重条件

在let 语句中使用if，if 和else 对应的必须是同一个类型。（什么时候用分号，什么时候不用）

##### loop

##### 从循环返回值

`loop` 的一个用例是重试可能会失败的操作，比如检查线程是否完成了任务。然而你可能会需要将操作的结果传递给其它的代码。要实现这一点，可以在用于停止循环的 `break` 表达式后添加你希望返回的值；这个值就会作为循环的返回值返回，这样你就可以使用它。

##### 循环标签

如果存在嵌套循环，`break` 和 `continue` 应用于此时最内层的循环。你可以选择在一个循环上指定一个 **循环标签**（*loop label*），然后将标签与 `break` 或 `continue` 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。

##### while

条件是true一直执行

##### for

```rust
for i in a{
    
}
for number in (1..4).rev() {
        println!("{number}!");
}
```

### 认识所有权

#### 作用域

所有权（系统）是 Rust 最为与众不同的特性，对语言的其他部分有着深刻含义。它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全，因此理解 Rust 中所有权如何工作是十分重要的。本章，我们将讲到所有权以及相关功能：借用（borrowing）、slice 以及 Rust 如何在内存中布局数据。

Rust 内存管理：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序的运行。

1. Rust 中的每一个值都有一个 **所有者**（*owner*）。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者离开作用域，这个值将被丢弃。

Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。

当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 [`drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop)，在这里 `String` 的作者可以放置释放内存的代码。Rust 在结尾的 `}` 处自动调用 `drop`。

隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何**自动**的复制都可以被认为是对运行时性能影响较小的

```
Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章将会详细讲解 trait）。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然有效。

Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。要学习如何为你的类型添加 Copy 注解以实现该 trait，请阅读附录 C 中的 “可派生的 trait”。

那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：

所有整数类型，比如 u32。
布尔类型，bool，它的值是 true 和 false。
所有浮点数类型，比如 f64。
字符类型，char。
元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。
```

#### 所有权与函数

相当于c++ 的move 语义，做了所有权的转移。

Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 **引用**（*references*）。

### 引用和借用

#### 引用

正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。

可变引用，也就是&mut String(类型)

我们**也**不能在拥有不可变引用的同时拥有可变引用。

#### 借用

#### 悬垂引用

在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个**悬垂指针**（*dangling pointer*）—— 指向可能已被分配给其他用途的内存位置的指针。

让我们概括一下之前对引用的讨论：

- 在任意给定时间，**要么**只能有一个可变引用，**要么**只能有多个不可变引用。
- 引用必须总是有效的。

### slice

**切片**（*slice*）允许你引用集合中**一段**连续的元素序列，而不用引用整个集合。slice 是一种引用，所以它不拥有所有权。

对于String 来说，&s[begin, end]

对于基本数组，&类型变量[begin, end]

`enumerate` 返回的元组中，第一个元素是索引，第二个元素是集合中元素的引用

 `s` 的类型是 `&str`

这种灵活性利用了 *deref coercions* 的优势，这个特性在**“函数和方法的隐式 Deref 强制转换”**中介绍。

### Struct

一旦定义了结构体后，为了使用它，通过为每个字段指定具体值来创建这个结构体的**实例**。创建一个实例需要以结构体的名字开头，接着在大括号中使用 `key: value` 键 - 值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值。

1. 通过一个结构体给另一个结构体赋值

   ```rust
   let user1 = user {..};
   let user2 = User {
           email: String::from("another@example.com"),
           ..user1 // 注意是move 了user1 还是clone
   };
   ```

   `..user1` 必须放在最后，以指定其余的字段应从 `user1` 的相应字段中获取其值，但我们可以选择以任何顺序为任意字段指定值，而不用考虑结构体定义中字段的顺序。

2. 使用没有命名字段的元组结构体来创建不同的类型；也可以定义与元组类似的结构体，称为 **元组结构体**（*tuple structs*）。

3. xxx

4. xxx

5. xxx

6. 









