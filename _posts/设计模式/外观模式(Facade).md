---
title: 外观模式(Facade)【5星】
toc: true
date: 2023-08-20 22:26:59
tags:
- c++
categories:
- 设计模式
typora-root-url: ..\img
---

#### 动机

#### 概念

外部与一个子系统的通信必须通过一个统一的外部对象来进行调用，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，通过这个接口，我们能够方便的使用这个子系统。外观模式又称为门面模式，它是一种对象结构型模式。

#### 实现方式（类图）

- Facade: 外观角色
- Additional Facade: 附加外观 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
- SubSystem:子系统角色

![设计模式-抽象工厂-外观模式](/../../../../工作图库/设计模式-抽象工厂-外观模式.jpg)


#### 举例

<!-- more -->

##### 实际场景

* 如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式
* 如果需要将子系统组织为多层结构可以使用外观

##### 使用方法（核心代码）

```c++
//具体见github
class Facade {
public:
    Facade() {
        std::cout << "Facade()" << std::endl;
        system_a = std::make_shared<SystemA>();
        system_a = std::make_shared<SystemB>();
    }

    ~Facade() {
        std::cout << "~Facade()" << std::endl;
    }

    void work() {
        std::cout << "Facade::work()" << std::endl;
        system_a->work();
        system_a->work();
    }
private:
    std::shared_ptr<SystemA> system_a;
    std::shared_ptr<SystemB> system_b;
};

```

#### 模板方法模式适合应用场景

* 创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。
* 如果你需要一个指向复杂子系统的直接接口,且该接口的功能有限,则可以使用外观模

#### 模板方法模式优缺点

##### 优点：

* 一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。
* 如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。

##### 缺点：

* 要充分发挥这一模式的优势， 你必须确保所有客户端代码仅通过外观来与子系统进行交互。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。

#### 与其他模式的关系
