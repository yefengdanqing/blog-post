---
title: template method【3星】
toc: true
date: 2023-04-17 22:26:59
tags:
- c++
categories:
- 设计模式
typora-root-url: ..\img
---

#### 概念
##### 动机
* 在软件构建过程中，对于某一项任务，它常常有稳定的整体操作 结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 (比如框架与应用之间的关系)而无法和任务的整体结构同时实现。
* 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变 化或者晚期实现需求?

<!-- more -->

##### 定义

模板方法模式是一种行为设计模式，它定义了一个算法骨架，允许子类重写算法的某些步骤，但不改变该算法的结构。在模板方法模式中，抽象类定义了一个模板方法，这个方法包含了一系列的具体方法，其中部分方法可由子类进行实现。

模板方法模式的主要优点是：

1. 将算法的结构和具体实现分离，使得算法更易于维护和扩展。
2. 可以通过重写某些具体方法来改变算法的行为，同时保证算法的整体结构不受影响。
3. 提高了代码的复用性，避免了相似算法的重复代码。

<!-- more -->

模板方法模式通常适用于以下情况：

- 多个子类有共同的方法，并且基本逻辑相同，只是具体实现不同。

- 不希望子类改变算法的整体结构，只允许重写某些具体方法。

- 希望通过一种统一的方式来执行算法，避免了算法的重复代码。

- 对于固定的流程，可以使用钩子的方式来处理，避开或者重新定义这些固定的流程

- 由稳定的部分调用不稳定的部分。

#### 举例

##### 实际场景

比如每个人都要上班，每个人要打卡，也要下班；但是每个人可能做的事情不一样，有美工，有程序员，有财务等

##### 使用方法

```c++
// libray 的run 实现具体的流程
// application 继承library重写重要的业务逻辑
void library_code(Library* obj) {
  // ...
  obj->run();
  // ...
}

int main() {
    Library* base = new Application;
    library_code(base);
    /*
    Library* base = new Application_xxx;
    library_code(base);
    delete base
    */
    return 0;
}
//还是需要new 不同的子类对象，是否可以结合其他设计模式呢
```

#### 模板方法模式适合应用场景

* 当你只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时，可使用模板方法模式
* 当多个类的算法除一些细微不同之外几乎完全一样时，你可使用该模式。但其后果就是只要算法发生变化，你就可能需要修改所有的类

#### 实现方式（类图）

![image-20230420102358849](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/image-20230420102358849.png)

#### 模板方法模式优缺点

优点：

-  你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。

-  你可将重复代码提取到一个超类中。

缺点：

-  部分客户端可能会受到算法框架的限制。
-  通过子类抑制默认步骤实现可能会导致违反*里氏替换原则*。
-  模板方法中的步骤越多， 其维护工作就可能会越困难。

#### 与其他模式的关系

- 工厂方法模式是模板方法模式的一种特殊形式。 同时， *工厂方法*可以作为一个大型*模板方法*中的一个步骤。
- 模板方法基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 *模板方法*在类层次上运作， 因此它是静态的。 *策略*在对象层次上运作， 因此允许在运行时切换行为。





