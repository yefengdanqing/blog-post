---
title: 策略设计模式【5星】
toc: true
date: 2023-03-08 22:26:59
tags:
- c++
categories:
- 设计模式
typora-root-url: ..\img
---

#### 动机

* 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂; 而且有时候支持不使用的算法也是一个性能负担。
* 如何在运行时根据需要透明地更改对象的算法?将算法与对象本 身解耦，从而避免上述问题?

#### 概念

策略设计模式是一种面向对象编程的模式，它允许在运行时为一个特定的算法族中的某个算法选择合适的实现。该模式通过定义一个通用接口，然后实现多个具体类来实现算法的封装和互换。这样就可以更灵活、更容易地修改或扩展一个应用程序的算法部分，而不需要修改整个应用程序的结构。

定义一系列算法，把它们一个个封装起来，并且使它们可互 相替换(变化)。该模式使得算法可独立于使用它的客户程 序(稳定)而变化(扩展，子类化)

<!-- more -->

#### 实现方式（类图）

![image-20230420003913340](/../../../../Library/Application Support/typora-user-images/image-20230420003913340.png)



#### 举例

<!-- more -->

##### 实际场景

假如王二狗和牛翠花约好在天安门约会，两人从起点到目的地可以借助的通行方式比较多，至于选那种方式完全因人而异。

##### 使用方法（核心代码）

```c++
//具体见github
class Context {
public:
    explicit Context(std::unique_ptr<MapStrategy>&& str) : strategy(std::move(str)) {
        //参数和成员变量一定不要一样命名
    }
    void context_do_something() {
        strategy->who();
        if (strategy == nullptr) {
            std::cout << "strategy == nullptr" << std::endl;
        } else {
            strategy->route();
            std::cout << "strategy finish" << std::endl;
        }
    }
    void set_strategy(std::unique_ptr<MapStrategy>&& str) {
        strategy = std::move(str);
        // strategy->who();

    }
private:
    std::unique_ptr<MapStrategy> strategy; //一定要是指针或者引用，通过指针实现策略的多态， strategy的析构一定是virtual
};

```

#### 应用场景

#### 优缺点

##### 优点：

* Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。
* Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。
* 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销

##### 缺点：

#### 与其他模式的关系
