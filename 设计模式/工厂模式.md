---
title: 工厂模式【5星】
toc: true
date: 2023-04-21 22:26:59
tags:
- c++
categories:
- 设计模式
typora-root-url: ..\img
---

### 简单工厂模式

#### 动机

* 考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式
* 将对象的创建和对象相关的业务分开，相当于一层简单的解耦
* 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。
* 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。
* 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

<!-- more -->

#### 概念

简单工厂模式又叫静态工厂模式，是一种类创建模式。在该模式中，通过不同的参数创建不同的类对象，但是这些类具有共同的父类。

**工厂类**:负责根据不同的参数创建不同的实例。

**IProduct: 抽象产品角色** 所有产品实例的接口，负责描述所有产品实例的行为。

**Product(A B ..): 具象产品角色** 所有产品的实例，实现了抽象产品定义的代码。

#### 实现方式（类图）

![image-20230801164819499](/../../../../Library/Application Support/typora-user-images/image-20230801164819499.png)

#### 举例

##### 实际场景

一个工厂通过name来获取产品的对象

##### 使用方法（核心代码）

```c++
//具体见github
std::shared_ptr<Product> Factory::create(const std::string& name) {
    if (name == "ProductA") {
        return std::make_shared<ProductA>();
    } else if (name == "ProductB") {
        return std::make_shared<ProductB>();
    } else {
        std::cout << "No such product" << std::endl;
        return nullptr;
        // return std::make_shared<Product>();
    }
}
```

#### 适合应用场景

- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

#### 模式优缺点

##### 优点：

- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

##### 缺点：

- 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
- 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

#### 与其他模式的关系

1. 工厂方法模式（Factory Method Pattern）：简单工厂模式可以视为工厂方法模式的一种特殊形式。工厂方法模式通过定义一个抽象的工厂接口，让子类决定实例化哪个具体的产品对象。而简单工厂模式中的工厂类负责创建所有的产品对象，无需子类来进行选择。
2. 抽象工厂模式（Abstract Factory Pattern）：抽象工厂模式是一种提供了一组相关或依赖对象创建的接口，用于创建一系列相关的产品对象。它与简单工厂模式的区别在于抽象工厂模式关注一系列相关的产品对象的创建，而简单工厂模式只关心单一对象的创建。
3. 单例模式（Singleton Pattern）：简单工厂模式可以与单例模式结合使用，以确保工厂类只有一个实例。这样可以避免多个工厂对象的创建，保持对象创建的一致性。
4. 策略模式（Strategy Pattern）：简单工厂模式可以与策略模式结合使用，以提供不同的策略对象。工厂类根据参数或条件决定要创建哪个具体的策略对象，并将其返回给客户端使用。

可能需要考虑使用其他更为灵活和可扩展的创建型设计模式，如工厂方法模式、抽象工厂模式或建造者模式等。

### 工厂方法模式

#### 动机

由于简单工厂模式中，由直接的工厂类来创建对应的产品的话，这样就会违背开闭原则。首先先定义一个抽象工厂类，然后定义具体的工厂类来实现创建各个具体产品的对象，而定义创建具体对象的借口由工厂父类提供。

#### 概念

工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类负责具体的产品对象的创建。这样做的目的是将产品类的实例化延续到工厂子类中完成。即通过工厂子类来确定究竟是实例化哪一个产品对象

#### 实现方式（类图）

- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂

![image-20230810151003229](/../../../../Library/Application Support/typora-user-images/image-20230810151003229.png)

![image-20230810165116965](/../../../../Library/Application Support/typora-user-images/image-20230810165116965.png)

#### 举例

日志记录器

某系统日志记录器需要支持多种日志记录相关的功能，比如文件记录的方式、数据库的记录方式。用户可以根据需要动态的选择哪一种方式，现在使用工厂方法模式实现该功能。

##### 实际场景

A和B产品由对应的工厂创建

##### 使用方法（核心代码）

```c++
//具体见github
//定义
class ConcreteProductA : public Product {
public:
    ConcreteProductA() {}
    virtual ~ConcreteProductA() {}
    virtual void use() {
        std::cout << "ConcreteProductA" << std::endl;
    }

};


class ConcreteFactoryA : public Factory
{
public:
    ConcreteFactoryA() {}
    virtual ~ConcreteFactoryA() {}
    virtual std::shared_ptr<Product> CreateProduct() override {
        return std::make_shared<ConcreteProductA>();
    }

};


//使用
{
		std::cout << "Hello, World!" << std::endl;
    auto factory_a = std::make_unique<ConcreteFactoryA>();
    factory_a->CreateProduct()->use();

    auto factory_b = std::make_unique<ConcreteFactoryB>();
    factory_b->CreateProduct()->use();
}
```

#### 模式适合应用场景

* 一个类不知道使用对象的类是啥样，无法预知该对象的类型和其依赖关系的时候，工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码
* 如果你希望客户端能够扩展框架或者基础库里面的组件，可以将组件理解为产品，基础库或者框架理解为工厂类，进行扩展和重写。
* 如果你要复用对象，可以将对象保存在工厂类的vector、map、list中，而不用每次都创建对象，这个时候可以用工厂方法模式。首先， 需要创建存储空间来存放所有已经创建的对象;其次增加获取接口，然后将结果返回给调用方；再次，如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中)

#### 模式优缺点

##### 优点：

* 可以避免创建者或者调用方和产品之间的紧密耦合
* 解决了简单工厂模式的开闭原则，不用每次加产品都要修改工厂的接口【符合开闭原则】
* 符合单一职责原则：可以将产品创建代码放在单一位置， 从而使得代码更容易维护。

##### 缺点：

* 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
* 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类【业务上来说是合理的】，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。

#### 与其他模式的关系

- 在许多设计工作的初期都会使用工厂方法模式（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式（更灵活但更加复杂）。
- 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。
- 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。
- 原型并不基于继承， 因此没有继承的缺点。 另一方面， *原型*需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。
- 工厂方法是模板方法模式的一种特殊形式。 同时， *工厂方法*可以作为一个大型*模板方法*中的一个步骤。

### 抽象工厂模式

#### 动机

为了更清晰地理解工厂方法模式，需要先引入两个概念：

- **产品等级结构** ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。标识同一种产品为一个等级，不同的产品就是不同的等级。
- **产品族** ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。标识不同的产品，但是有同样的标识。

在工厂方法模式中，每个子类工厂代表一个产品具体的工厂类，由这个工厂类产生一种具体的产品。一般情况下，一个具体的工厂类只有一个工厂方法或者一组类似的工厂的方法。有时候我们需要一个工厂能够返回一些列产品，而不是单一的产品。

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。



#### 概念

抽象工厂就是围绕一个超级工厂创建不同产品对象的具体工厂。提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

#### 实现方式（类图）

- AbstractFactory：抽象工厂（非单一产品）

- ConcreteFactory：具体工厂

- AbstractProduct：抽象产品

- Product：具体产品

  ![设计模式-抽象工厂-抽象工厂](https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.jpg)

#### 举例

比如小米、苹果和华为工厂，他们有不同的产品等级，比如手机、电视、car。

##### 实际场景

##### 使用方法（核心代码）

```c++
//具体见github
		//超级抽象工厂
	 class AbstractFactory {
       virtual std::shared_ptr<AbstractPhoneProduct> create_phone() = 0;
       virtual std::shared_ptr<AbstractTvProduct> create_tv() = 0;
   	   virtual std::shared_ptr<AbstractPcProduct> create_pc() = 0;
   };

    auto apple_factory = std::make_shared<AppleFactory>();
    auto apple_phone = apple_factory->create_phone();
    auto apple_tv = apple_factory->create_tv();
    auto apple_pc = apple_factory->create_pc();
    apple_phone->bell();
    apple_phone->call();
    apple_pc->down();
    apple_pc->work();
    apple_tv->play();
    apple_tv->open();


    auto huawei_factory = std::make_shared<HuaweiFactory>();
    auto huawei_phone = huawei_factory->create_phone();
    auto huawei_tv = huawei_factory->create_tv();
    auto huawei_pc = huawei_factory->create_pc();
    huawei_phone->bell();
    huawei_phone->call();
    huawei_pc->down();
    huawei_pc->work();
    huawei_tv->play();
    huawei_tv->open();

```

#### 模板方法模式适合应用场景

* 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
* 系统中有多于一个的产品族，而每次只使用其中某一产品族
* 在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。

#### 模板方法模式优缺点

##### 优点：

* 当需要增加一个具体的产品的时候，只需要继承抽象父产品类，改动很小【由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。】
* 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建

* 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。

##### 缺点：

* 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）
* 在添加新的产品对象时，扩展抽象工厂来生产新种类的产品改动会很大，这因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改。

#### 与其他模式的关系

### 总结

参考：

https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html

https://refactoringguru.cn/design-patterns/factory-method

