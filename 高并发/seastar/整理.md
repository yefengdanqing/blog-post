---
title: 环境配置
toc: true
date: 2022-08-18 22:26:59
tags:
- 
categories:
- 
typora-root-url: ..\img
---

### 语法

#### then和wrap_then

在 Seastar 中，`then` 和 `wrap_then` 都是 Future 对象的方法，它们的作用都是将当前 Future 与另一个 Future 进行组合。不过，两者之间还是有一些区别的。

* then

`then` 方法会在当前 Future 完成后立即执行指定的回调函数，并返回一个新的 Future 对象。这个新的 Future 对象表示回调函数的返回值。如果回调函数抛出了任何异常，则新的 Future 对象将设置为该异常，并进入异常状态。例如：

```
auto f1 = read_file_async("file1.txt").then([] (auto data) {
    // 对读取到的文件数据进行处理
    return process_data_async(data);
}).then([] (auto result) {
    // 处理结果
    return result;
});
```

在上述代码中，第一个 `then` 方法在完成文件读取操作后调用回调函数，对读取到的文件数据进行处理，并返回一个新的 Future 对象。第二个 `then` 方法则在第一个 `then` 方法返回的 Future 对象完成后执行，对处理结果进行进一步处理。

<!-- more -->

* wrap_then

`wrap_then` 方法也会在当前 Future 完成后立即执行指定的回调函数，但是返回的是当前 Future 对象本身，而不是新的 Future 对象。此外，回调函数必须接受当前 Future 包含的值作为参数，并返回一个新的 Future 对象。如果回调函数抛出了任何异常，则当前 Future 对象将设置为该异常，并进入异常状态。例如：

```
cpp复制代码auto f1 = read_file_async("file1.txt");
f1.wrap_then([] (auto data) {
    // 对读取到的文件数据进行处理
    return process_data_async(data);
}).then([] (auto result) {
    // 处理结果
    return result;
});
```

在上述代码中，我们首先创建了一个 `read_file_async` 函数返回的 Future 对象 `f1`，然后使用 `wrap_then` 方法添加回调函数，对读取到的文件数据进行处理，并返回一个新的 Future 对象。由于 `wrap_then` 方法返回的是当前 Future 对象本身，因此我们可以在其后面继续链接其他操作，例如使用 `then` 方法对处理结果进行进一步处理。

总之，在 Seastar 中，`then` 和 `wrap_then` 方法都可以用来组合 Future 对象，但是它们的返回值和参数列表略有不同。需要根据实际业务需求选择合适的方法，以便更好地利用 Future 的异步特性。
